\documentclass[a4paper,oneside]{article}
\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage[english]{babel}

\usepackage[margin=2.54cm]{geometry}
\usepackage{amsmath}
\usepackage{bbm}
\usepackage{siunitx}
\usepackage{listings}
\usepackage{color}
\usepackage{textcomp}
\usepackage{graphicx}
\usepackage{subcaption}
%\usepackage{changepage}
\usepackage[section]{placeins}
\usepackage{hyperref}

\definecolor{matlabgreen}{RGB}{28,172,0}
\definecolor{matlablilas}{RGB}{170,55,241}

\newcommand{\includecode}[1]{\lstinputlisting[caption={\ttfamily #1.m},label={lst:#1}]{matlab/#1.m}}
\newcommand{\inlinecode}[1]{\lstinline[basicstyle=\ttfamily,keywordstyle={},stringstyle={},commentstyle={\itshape}]{#1}}

\renewcommand{\vec}[1]{\underline{#1}}
\renewcommand{\Re}[1]{\operatorname{Re}\left[#1\right]}
\newcommand{\E}[1]{\operatorname{E}\left[#1\right]}
\newcommand{\norm}[1]{\left\lVert#1\right\rVert}
\newcommand{\abs}[1]{\left|#1\right|}
\newcommand{\F}[1]{\operatorname{\mathcal{F}}\left[#1\right]}
\newcommand{\ceil}[1]{\left\lceil#1\right\rceil}
\newcommand{\floor}[1]{\left\lfloor#1\right\rfloor}
\newcommand{\Prob}[1]{\operatorname{P}\left[#1\right]}
\newcommand{\ProbC}[2]{\operatorname{P}\left[#1\middle|#2\right]}
\newcommand{\ind}[1]{\operatorname{\mathbbm{1}}\left\{#1\right\}}
\newcommand{\distr}[0]{\sim}
\newcommand{\unif}[1]{\mathcal{U}_{#1}}

\newcolumntype{M}{>{$}r<{$}}

\author{Riccardo Zanol}
\title{Homework 2}

\begin{document}
\lstset{
  language=Matlab,
  basicstyle={\ttfamily \footnotesize},
  breaklines=true,
  morekeywords={true,false,warning,xlim,ylim},
  keywordstyle=\color{blue},
  stringstyle=\color{matlablilas},
  commentstyle={\color{matlabgreen} \itshape},
  numberstyle={\ttfamily \tiny},
  frame=leftline,
  showstringspaces=false,
  numbers=left,
  upquote=true,
}
\maketitle
\section*{1}
The function \inlinecode{lcg} implements a Linear Congruential
Generator, which is a RNG than produces a specified number of samples
from the sequence $x_k$, according to the equation
\[ x_{k} = ax_{k-1} +b \mod m  \]
and starting with a given $x_0$.  To replicate Figure~6.5 a LCG with
parameters $a=16807$,~$b=0$~and~$m=2^{31}-1$ is initialized with the
seed value $x_0 = 1$, the first 1000 numbers that it generates are
then sorted and plotted in Fig.~\ref{plot:qqplot}, where they look to
be uniformly distributed in $[0,1]$.  From their autocorrelation
(Fig.~\ref{plot:autocorr}) and their lag plots
(Fig.~\ref{plot:lagplot}) the generated numbers appear to be
uncorrelated.
\begin{figure}[htbp]
  \centering
  \begin{subfigure}{0.5\textwidth}
    \centering
    \includegraphics[width=0.95\textwidth]{matlab/uniform_qq}
    \caption{QQ plot}
    \label{plot:qqplot}
  \end{subfigure}%
  \begin{subfigure}{0.5\textwidth}
        \centering
    \includegraphics[width=0.95\textwidth]{matlab/rand1_autocorr}
    \caption{Autocorrelation}
    \label{plot:autocorr}
  \end{subfigure}
  \begin{subfigure}{0.75\textwidth}
        \centering
    \includegraphics[width=\textwidth]{matlab/rand1_lagplot}
    \caption{Lag plot}
    \label{plot:lagplot}
  \end{subfigure}
  \caption{LCG}
\end{figure}

Using the same LCG to generate two sequences the results are very
different depending on the choice of the seed values: if the two
parallel sequences start with 1 and 2, their output is very correlated
as can be seen in Fig.~\ref{plot:lcg_close_seeds}. If, instead, the
second stream starts from the last value of the first one the two
sequences look independent in Fig.\ref{plot:lcg_far_seeds}.
\begin{figure}[htbp]
  \centering
  \begin{subfigure}{0.5\textwidth}
    \centering
    \includegraphics[width=0.95\textwidth]{matlab/lcg_close_seeds}
    \caption{Parallel streams with close seeds}
    \label{plot:lcg_close_seeds}
  \end{subfigure}%
  \begin{subfigure}{0.5\textwidth}
    \centering
    \includegraphics[width=0.95\textwidth]{matlab/lcg_far_seeds}
    \caption{Parallel streams with no overlap}
    \label{plot:lcg_far_seeds}
  \end{subfigure}
  \caption{Parallel streams}
\end{figure}

To generate a random variable $Y_1$ with p.d.f.
\[ f_{Y_1}(y) = K\frac{\sin^2(y)}{y^2} \qquad -10 \leq y \leq 10 \]
it is possible to use the algorithm based on theorem 6.3 (rejection
sampling for distribution with density), where the upper bound of
$f_{Y_1}^n$ is $M=1$ and the interval where the r.v. $X$ is drawn from
is $[-10,10]$. The histogram of 2000 generated samples of $Y_1$ is
shown in Fig.~\ref{plot:rejection_histo}.
\begin{figure}[htbp]
  \centering
  \begin{subfigure}{0.5\textwidth}
    \centering
    \includegraphics[width=0.95\textwidth]{matlab/rejection_histo}
    \caption{Histogram of $Y_1$}
    \label{plot:rejection_histo}
  \end{subfigure}%
  \begin{subfigure}{0.5\textwidth}
    \centering
    \includegraphics[width=0.95\textwidth]{matlab/rejection_scatter}
    \caption{Generated values of $Y_2$}
    \label{plot:rejection_scatter}
  \end{subfigure}
  \caption{Rejection sampling}
\end{figure}

The other random variable $Y_2$ with p.d.f.
\[ f_{Y_2}(y_1, y_2) = K\abs{y_1 - y_2} \qquad (y_1, y_2) \in [0, 1]^2 \]
can be generated in the same way: the upper bound on $f_{Y_2}^n$ is
$M=1$ also in this case and the random variable $X = (X_1, X_2)$ is
drawn by generating two r.v.s $X_1, X_2 \distr \unif{[0,1]}$. In
Fig.~\ref{plot:rejection_scatter} are shown 2000 samples produced with
this method.
\section*{2}
In Tab.~\ref{tab:binomial} there are the times it takes to generate
$N=10^5$ Binomial random variables with parameters $n$ and $p$ using
three different methods:
\begin{enumerate}
\item By using the algorithm based on the CDF inversion that
  iteratively computes
  \begin{align*}
    \mathrm{pr}(i) &= \Prob{X = i} = \frac{p}{1-p}\frac{n-i}{i+1}\Prob{X = i-1} \\
    F(i) &= F(i-1) + \mathrm{pr}(i) ,
  \end{align*}
  stops as soon as $F(i) > U$, where $U$ is a uniform r.v. in $[0,
    1]$, and takes $x = i$ as the realization of the Binomial r.v.
  \item By generating $n$ Bernoullian r.v.s and counting the number of
    successes, where each Bernoullian $b_i$ is generated from a uniform
    r.v. $U_i$ as $b_i = \ind{U_i \leq p}$.
  \item By generating a string of zeros of length $K_i$, geometrically
    distributed with parameter $p$, counting a one at $K_i+1$ and
    iterating until $\sum_i \left( K_i + 1 \right) > n$. The geometric
    r.v.s are generated, using the CDF inversion method, as
    \[ K_i = \floor{\frac{\ln U_i}{\ln (1 - p)}} . \]
\end{enumerate}
\begin{table}[h]
  \centering
  \begin{tabular}{MM|MMM}
    \multicolumn{2}{c}{Binomial parameters} &
    \multicolumn{1}{c}{CDF inversion} &
    \multicolumn{1}{c}{Sum of Bernoullians} &
    \multicolumn{1}{c}{Geometric sequences of zeros} \\
    \hline
    n = 10 & p = 0.0001 & \SI{2.523}{\s} & \SI{0.856}{\s} & \SI{1.568}{\s} \\
    n = 10 & p = 0.0100 & \SI{2.456}{\s} & \SI{0.864}{\s} & \SI{1.520}{\s} \\
    n = 10 & p = 0.5000 & \SI{2.517}{\s} & \SI{0.822}{\s} & \SI{1.731}{\s} \\
    n = 10 & p = 0.9000 & \SI{2.555}{\s} & \SI{0.867}{\s} & \SI{1.752}{\s} \\
    n = 50 & p = 0.0001 & \SI{2.537}{\s} & \SI{0.996}{\s} & \SI{1.594}{\s} \\
    n = 50 & p = 0.0100 & \SI{2.517}{\s} & \SI{0.974}{\s} & \SI{1.630}{\s} \\
    n = 50 & p = 0.5000 & \SI{2.518}{\s} & \SI{1.069}{\s} & \SI{1.886}{\s} \\
    n = 50 & p = 0.9000 & \SI{2.637}{\s} & \SI{0.979}{\s} & \SI{2.171}{\s} \\
    n = 100 & p = 0.0001 & \SI{2.428}{\s} & \SI{1.134}{\s} & \SI{1.434}{\s} \\
    n = 100 & p = 0.0100 & \SI{2.539}{\s} & \SI{1.147}{\s} & \SI{1.630}{\s} \\
    n = 100 & p = 0.5000 & \SI{2.622}{\s} & \SI{1.242}{\s} & \SI{2.299}{\s} \\
    n = 100 & p = 0.9000 & \SI{2.717}{\s} & \SI{1.166}{\s} & \SI{2.733}{\s} \\
    n = 200 & p = 0.0001 & \SI{2.602}{\s} & \SI{1.504}{\s} & \SI{1.579}{\s} \\
    n = 200 & p = 0.0100 & \SI{2.496}{\s} & \SI{1.492}{\s} & \SI{1.575}{\s} \\
    n = 200 & p = 0.5000 & \SI{2.757}{\s} & \SI{1.697}{\s} & \SI{2.923}{\s} \\
    n = 200 & p = 0.9000 & \SI{3.005}{\s} & \SI{1.569}{\s} & \SI{3.950}{\s} \\
    n = 1000 & p = 0.0001 & \SI{2.471}{\s} & \SI{4.511}{\s} & \SI{1.680}{\s} \\
    n = 1000 & p = 0.0100 & \SI{2.560}{\s} & \SI{4.535}{\s} & \SI{1.670}{\s} \\
    n = 1000 & p = 0.5000 & \SI{3.841}{\s} & \SI{5.415}{\s} & \SI{8.050}{\s} \\
    n = 1000 & p = 0.9000 & - & \SI{4.776}{\s} & \SI{14.127}{\s} \\
  \end{tabular}
  \caption{Timing of three Binomial generation methods}
  \label{tab:binomial}
\end{table}

As $n$ increases, the execution time for the second algorithm
increases linearly and, for all the values of $n \neq 1000$ tried, it
is the quickest of the three methods.

The third algorithm's speed depends on the number of geometric samples
that must be generated, which is $\approx \frac{n}{(1-p)/p}$ on
average: when $p$ is small the execution time increases linearly in
$n$ but very slowly, so this algorithm gives the best performance in
the tested cases when $n = 1000$ and $p \in \{10^{-4}, 10^{-2}\}$. As
$p$ becomes closer and closer to 1, on the other hand, the execution
time grows more quickly (in the tested cases for $n \geq 100$ and $p
\in \{0.5, 0.9\}$ this algorithm is the worst performing one).

The execution time of the CDF inversion should depend on the value of
the generated sample, which is on average $np$, because it runs for
$x=i$ iterations but in the tested cases it does not seem to vary
much.  Even when $np$ changes of a factor $10^4$ the time to generate
the Binomial r.v.s remains around the same value. The time this
algorithm takes is quite high compared to the other two methods for
small values of $n$ but it becomes the best when $n = 1000$ and $p =
0.5$. In the case $n = 1000$, $p=0.9$ the algorithm does not terminate
because the probability $\mathrm{pr}(0) = (1-p)^n$ becomes so small
that Matlab represents it with 0.
\section*{3}

\end{document}
